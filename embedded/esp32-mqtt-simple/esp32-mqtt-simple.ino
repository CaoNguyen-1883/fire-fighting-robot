/*
 * ESP32 MQTT CONTROL - FIRE FIGHTING ROBOT
 * Chức năng: Điều khiển motor + pump qua MQTT + Sensors
 * Linh kiện:
 *   - ESP32 Wroom-32
 *   - L298N Motor Driver
 *   - 4x DC Motor 3V
 *   - Relay + Water Pump 12V
 *   - HC-SR04 Ultrasonic Sensor (Distance)
 *   - Flame Detector (Analog + Digital)
 */

//  INCLUDE LIBRARIES 
#include <WiFi.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>

// CONFIGURATION 

// WiFi Settings
const char* WIFI_SSID = "KTX-H05";        // Thay tên WiFi
const char* WIFI_PASSWORD = "@Concac123";      // Thay mật khẩu WiFi
// const char* WIFI_SSID = "YCaoNguyen";        // Thay tên WiFi
// const char* WIFI_PASSWORD = "12345678";      // Thay mật khẩu WiFi



// // MQTT Settings
const char* MQTT_BROKER = "192.168.1.8";       // IP máy tính chạy Mosquitto
// const char* MQTT_BROKER = "192.168.137.1"; //Hotpot laptop
const int MQTT_PORT = 1883;
const char* MQTT_CLIENT_ID = "ESP32_FireRobot";

// MQTT Topics
const char* TOPIC_MOTOR_CONTROL = "robot/control/motor";
const char* TOPIC_PUMP_CONTROL = "robot/control/pump";
const char* TOPIC_STATUS = "robot/status";
const char* TOPIC_SENSOR_DISTANCE = "robot/sensors/distance";
const char* TOPIC_SENSOR_FLAME = "robot/sensors/flame";

// PIN DEFINITIONS

// Motor Control Pins (L298N)
#define MOTOR_ENA 25    // PWM Left Motor (Enable A)
#define MOTOR_IN1 12    // Left Motor Direction 1
#define MOTOR_IN2 13    // Left Motor Direction 2
#define MOTOR_ENB 26    // PWM Right Motor (Enable B)
#define MOTOR_IN3 14    // Right Motor Direction 1
#define MOTOR_IN4 27    // Right Motor Direction 2

// Pump Control
#define PUMP_RELAY 32   

// Sensor Pins
#define ULTRASONIC_TRIG 18  // HC-SR04 Trigger
#define ULTRASONIC_ECHO 19  // HC-SR04 Echo1
#define FLAME_ANALOG 34     // Flame Sensor Analog Output
#define FLAME_DIGITAL 4     // Flame Sensor Digital Output

// LED Built-in
#define LED_BUILTIN 2

// PWM SETTINGS
#define PWM_CHANNEL_LEFT 0
#define PWM_CHANNEL_RIGHT 1
#define PWM_FREQ 1000           // 1kHz PWM frequency
#define PWM_RESOLUTION 8        // 8-bit resolution (0-255)

// GLOBAL VARIABLES

// WiFi & MQTT Clients
WiFiClient espClient;
PubSubClient mqtt(espClient);

// Robot State
String currentMotorState = "stop";
int currentSpeed = 0;
bool pumpState = false;

// Timing Variables
unsigned long lastStatusUpdate = 0;
unsigned long lastWiFiCheck = 0;
unsigned long lastSensorUpdate = 0;
const unsigned long STATUS_INTERVAL = 1000;    // Publish status mỗi 1 giây
const unsigned long SENSOR_INTERVAL = 500;     // Publish sensor data mỗi 500ms
const unsigned long WIFI_CHECK_INTERVAL = 30000; // Check WiFi mỗi 30 giây

// Connection Status
bool mqttConnected = false;

// Sensor Data
float currentDistance = 0.0;
int currentFlameAnalog = 0;
bool currentFlameDigital = false;

// MOTOR CONTROL FUNCTIONS

void setupMotors() {
  Serial.println("[SETUP] Initializing motors...");

  // CRITICAL: Set all direction pins to LOW FIRST to prevent random movement
  pinMode(MOTOR_IN1, OUTPUT);
  digitalWrite(MOTOR_IN1, LOW);

  pinMode(MOTOR_IN2, OUTPUT);
  digitalWrite(MOTOR_IN2, LOW);

  pinMode(MOTOR_IN3, OUTPUT);
  digitalWrite(MOTOR_IN3, LOW);

  pinMode(MOTOR_IN4, OUTPUT);
  digitalWrite(MOTOR_IN4, LOW);

  // Setup PWM channels
  ledcSetup(PWM_CHANNEL_LEFT, PWM_FREQ, PWM_RESOLUTION);
  ledcSetup(PWM_CHANNEL_RIGHT, PWM_FREQ, PWM_RESOLUTION);

  // Attach PWM channels to pins
  ledcAttachPin(MOTOR_ENA, PWM_CHANNEL_LEFT);
  ledcAttachPin(MOTOR_ENB, PWM_CHANNEL_RIGHT);

  // Set PWM to 0 immediately
  ledcWrite(PWM_CHANNEL_LEFT, 0);
  ledcWrite(PWM_CHANNEL_RIGHT, 0);

  // Confirm motors stopped
  motorStop();

  Serial.println("[SETUP]  Motors initialized");
}

void motorForward(uint8_t speed) {
  // Left motor forward
  digitalWrite(MOTOR_IN1, LOW);
  digitalWrite(MOTOR_IN2, HIGH);

  // Right motor forward
  digitalWrite(MOTOR_IN3, LOW);
  digitalWrite(MOTOR_IN4, HIGH);

  // Set speed
  ledcWrite(PWM_CHANNEL_LEFT, speed);
  ledcWrite(PWM_CHANNEL_RIGHT, speed);

  currentMotorState = "forward";
  currentSpeed = speed;

  Serial.printf("[MOTOR] Forward - Speed: %d\n", speed);
}

void motorBackward(uint8_t speed) {
  // Left motor backward
  digitalWrite(MOTOR_IN1, HIGH);
  digitalWrite(MOTOR_IN2, LOW);

  // Right motor backward
  digitalWrite(MOTOR_IN3, HIGH);
  digitalWrite(MOTOR_IN4, LOW);

  // Set speed
  ledcWrite(PWM_CHANNEL_LEFT, speed);
  ledcWrite(PWM_CHANNEL_RIGHT, speed);

  currentMotorState = "backward";
  currentSpeed = speed;

  Serial.printf("[MOTOR] Backward - Speed: %d\n", speed);
}

void motorLeft(uint8_t speed) {
  // Left motor backward (rotate in place)
  digitalWrite(MOTOR_IN1, LOW);
  digitalWrite(MOTOR_IN2, HIGH);

  // Right motor forward
  digitalWrite(MOTOR_IN3, HIGH);
  digitalWrite(MOTOR_IN4, LOW);

  // Set speed
  ledcWrite(PWM_CHANNEL_LEFT, speed);
  ledcWrite(PWM_CHANNEL_RIGHT, speed);

  currentMotorState = "left";
  currentSpeed = speed;

  Serial.printf("[MOTOR] Turn Left - Speed: %d\n", speed);
}

void motorRight(uint8_t speed) {
  // Left motor forward
  digitalWrite(MOTOR_IN1, HIGH);
  digitalWrite(MOTOR_IN2, LOW);

  // Right motor backward (rotate in place)
  digitalWrite(MOTOR_IN3, LOW);
  digitalWrite(MOTOR_IN4, HIGH);

  // Set speed
  ledcWrite(PWM_CHANNEL_LEFT, speed);
  ledcWrite(PWM_CHANNEL_RIGHT, speed);

  currentMotorState = "right";
  currentSpeed = speed;

  Serial.printf("[MOTOR] Turn Right - Speed: %d\n", speed);
}

void motorStop() {
  // Stop all motors
  digitalWrite(MOTOR_IN1, LOW);
  digitalWrite(MOTOR_IN2, LOW);
  digitalWrite(MOTOR_IN3, LOW);
  digitalWrite(MOTOR_IN4, LOW);

  // Set speed to 0
  ledcWrite(PWM_CHANNEL_LEFT, 0);
  ledcWrite(PWM_CHANNEL_RIGHT, 0);

  currentMotorState = "stop";
  currentSpeed = 0;

  Serial.println("[MOTOR] Stop");
}

// PUMP CONTROL FUNCTIONS

void setupPump() {
  Serial.println("[SETUP] Initializing pump...");

  // CRITICAL: Active LOW relay - HIGH = OFF, LOW = ON
  pinMode(PUMP_RELAY, OUTPUT);
  digitalWrite(PUMP_RELAY, HIGH);  // Pump OFF (relay HIGH for Active LOW)

  // Double-check by setting HIGH again
  digitalWrite(PUMP_RELAY, HIGH);
  pumpState = false;

  Serial.println("[SETUP]  Pump initialized (OFF)");
}

void pumpOn() {
  digitalWrite(PUMP_RELAY, LOW);  // Active LOW: LOW = ON
  pumpState = true;
  Serial.println("[PUMP] ON");
}

void pumpOff() {
  digitalWrite(PUMP_RELAY, HIGH); // Active LOW: HIGH = OFF
  pumpState = false;
  Serial.println("[PUMP] OFF");
}

void pumpToggle() {
  if (pumpState) {
    pumpOff();
  } else {
    pumpOn();
  }
}

// SENSOR FUNCTIONS

void setupSensors() {
  Serial.println("[SETUP] Initializing sensors...");

  // HC-SR04 Ultrasonic
  pinMode(ULTRASONIC_TRIG, OUTPUT);
  pinMode(ULTRASONIC_ECHO, INPUT);
  digitalWrite(ULTRASONIC_TRIG, LOW);

  // Flame Sensor
  pinMode(FLAME_DIGITAL, INPUT_PULLUP);  // Pull-up để tránh floating
  pinMode(FLAME_ANALOG, INPUT);

  Serial.println("[SETUP] ✓ Sensors initialized");
}

float readDistance() {
  // Send 10us pulse to trigger
  digitalWrite(ULTRASONIC_TRIG, LOW);
  delayMicroseconds(2);
  digitalWrite(ULTRASONIC_TRIG, HIGH);
  delayMicroseconds(10);
  digitalWrite(ULTRASONIC_TRIG, LOW);

  // Read echo pulse duration (timeout 30ms = ~500cm max)
  long duration = pulseIn(ULTRASONIC_ECHO, HIGH, 30000);

  // Calculate distance in cm (speed of sound = 343m/s)
  // Distance = (duration / 2) / 29.1
  float distance = duration / 58.0;

  // Validate reading (HC-SR04 range: 2-400cm)
  if (distance < 2.0 || distance > 400.0) {
    return -1.0; // Invalid reading
  }

  return distance;
}

void readFlame() {
  // Digital output: LOW = fire detected, HIGH = no fire
  currentFlameDigital = (digitalRead(FLAME_DIGITAL) == LOW);

  // Analog output: Higher value = more IR light (fire)
  // ESP32 ADC: 0-4095 (12-bit)
  currentFlameAnalog = analogRead(FLAME_ANALOG);
}

void publishSensorData() {
  if (!mqtt.connected()) return;

  // Read sensors
  currentDistance = readDistance();
  readFlame();

  // Publish Distance
  if (currentDistance > 0) {
    StaticJsonDocument<128> distDoc;
    distDoc["distance"] = currentDistance;
    distDoc["unit"] = "cm";
    distDoc["timestamp"] = millis();

    char distBuffer[128];
    serializeJson(distDoc, distBuffer);
    mqtt.publish(TOPIC_SENSOR_DISTANCE, distBuffer);

    Serial.printf("[SENSOR] Distance: %.1f cm\n", currentDistance);
  } else {
    Serial.println("[SENSOR] Distance: Out of range");
  }

  // Publish Flame
  StaticJsonDocument<128> flameDoc;
  flameDoc["digital"] = currentFlameDigital;
  flameDoc["analog"] = currentFlameAnalog;
  flameDoc["timestamp"] = millis();

  char flameBuffer[128];
  serializeJson(flameDoc, flameBuffer);
  mqtt.publish(TOPIC_SENSOR_FLAME, flameBuffer);

  Serial.printf("[SENSOR] Flame - Digital: %s, Analog: %d\n", 
                currentFlameDigital ? "DETECTED" : "No fire", 
                currentFlameAnalog);
}

// WiFi FUNCTIONS

void connectWiFi() {
  Serial.println("\n[WiFi] Connecting to WiFi...");
  Serial.print("[WiFi] SSID: ");
  Serial.println(WIFI_SSID);
  Serial.print("[WiFi] Password: ");
  Serial.println(WIFI_PASSWORD);

  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);

  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 40) {
    delay(500);
    Serial.print(".");
    attempts++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n[WiFi]  Connected!");
    Serial.print("[WiFi] IP Address: ");
    Serial.println(WiFi.localIP());
    Serial.print("[WiFi] Signal Strength: ");
    Serial.print(WiFi.RSSI());
    Serial.println(" dBm");
  } else {
    Serial.println("\n[WiFi] Connection FAILED!");
    Serial.println("[WiFi] Please check SSID and password");
  }
}

void checkWiFi() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("[WiFi] ✗ Disconnected! Reconnecting...");
    connectWiFi();
  }
}

// MQTT FUNCTIONS

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  // Print received message
  Serial.print("[MQTT] ← Message on topic: ");
  Serial.println(topic);

  // Parse JSON payload
  StaticJsonDocument<256> doc;
  DeserializationError error = deserializeJson(doc, payload, length);

  if (error) {
    Serial.print("[MQTT] ✗ JSON parse error: ");
    Serial.println(error.c_str());
    return;
  }

  // MOTOR CONTROL
  if (strcmp(topic, TOPIC_MOTOR_CONTROL) == 0) {
    const char* action = doc["action"];
    int speed = doc["speed"] | 200;  // Default speed = 200

    // Execute motor command
    if (strcmp(action, "forward") == 0) {
      motorForward(speed);
    }
    else if (strcmp(action, "backward") == 0) {
      motorBackward(speed);
    }
    else if (strcmp(action, "left") == 0) {
      motorLeft(speed);
    }
    else if (strcmp(action, "right") == 0) {
      motorRight(speed);
    }
    else if (strcmp(action, "stop") == 0) {
      motorStop();
    }
    else {
      Serial.printf("[MOTOR] Unknown action: %s\n", action);
    }
  }

  // PUMP CONTROL
  else if (strcmp(topic, TOPIC_PUMP_CONTROL) == 0) {
    const char* state = doc["state"];

    if (strcmp(state, "on") == 0) {
      pumpOn();
    }
    else if (strcmp(state, "off") == 0) {
      pumpOff();
    }
    else if (strcmp(state, "toggle") == 0) {
      pumpToggle();
    }
    else {
      Serial.print("[PUMP] ✗ Unknown state: ");
      Serial.println(state);
    }
  }
}

void connectMQTT() {
    Serial.print("[MQTT] Connecting to broker ");
    Serial.print(MQTT_BROKER);
    Serial.print(":");
    Serial.print(MQTT_PORT);
    Serial.print(" as ");
    Serial.print(MQTT_CLIENT_ID);
    Serial.print("...");

    if (mqtt.connect(MQTT_CLIENT_ID)) {
      Serial.println(" Connected!");

      // Subscribe to control topics
      mqtt.subscribe(TOPIC_MOTOR_CONTROL);
      mqtt.subscribe(TOPIC_PUMP_CONTROL);

      Serial.println("[MQTT] Subscribed to topics:");
      Serial.print("  - ");
      Serial.println(TOPIC_MOTOR_CONTROL);
      Serial.print("  - ");
      Serial.println(TOPIC_PUMP_CONTROL);

      mqttConnected = true;

      // Blink LED to indicate connection
      for (int i = 0; i < 3; i++) {
        digitalWrite(LED_BUILTIN, HIGH);
        delay(100);
        digitalWrite(LED_BUILTIN, LOW);
        delay(100);
      }

    } else {
      Serial.print(" Failed! rc=");
      Serial.print(mqtt.state());
      Serial.println(" | Retrying in 3 seconds...");

      mqttConnected = false;
      delay(3000);
    }
  }

void publishStatus() {
  if (!mqtt.connected()) return;

  // Create JSON status
  StaticJsonDocument<256> doc;
  doc["motor"] = currentMotorState;
  doc["motor_speed"] = currentSpeed;
  doc["pump"] = pumpState;
  doc["wifi_rssi"] = WiFi.RSSI();
  doc["uptime"] = millis() / 1000;      // seconds
  doc["free_heap"] = ESP.getFreeHeap();
  doc["mqtt_connected"] = mqttConnected;

  // Serialize to string
  char buffer[256];
  serializeJson(doc, buffer);

  // Publish to MQTT
  bool success = mqtt.publish(TOPIC_STATUS, buffer);

  if (success) {
    Serial.print("[MQTT] → Status published: ");
    Serial.println(buffer);
  } else {
    Serial.println("[MQTT] Failed to publish status");
  }
}


// SETUP


void setup() {
  // Initialize Serial Monitor
  Serial.begin(115200);
  delay(1000);

  // Print header
  Serial.println("\n\n");
  Serial.println("  FIRE FIGHTING ROBOT - ESP32");
  Serial.println("  MQTT Control System");
  Serial.println("-----------------------------------------\n");

  // Initialize LED
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, LOW);

  // Initialize Hardware
  setupMotors();
  setupPump();
  setupSensors();

  // CRITICAL: Ensure pump is OFF before any MQTT activity
  pumpOff();
  delay(100); // Small delay to ensure relay is OFF

  // Connect to WiFi
  connectWiFi();

  // Setup MQTT
  mqtt.setServer(MQTT_BROKER, MQTT_PORT);
  mqtt.setCallback(mqttCallback);

  // Connect to MQTT broker
  if (WiFi.status() == WL_CONNECTED) {
    connectMQTT();
  }

  Serial.println("  SYSTEM READY!");
  Serial.println("Waiting for MQTT commands...\n");
}


// MAIN LOOP - OPTIMIZED FOR LOW LATENCY

void loop() {
  // Check WiFi connection every 30 seconds
  if (millis() - lastWiFiCheck > WIFI_CHECK_INTERVAL) {
    checkWiFi();
    lastWiFiCheck = millis();
  }

  // Check MQTT connection
  if (!mqtt.connected()) {
    mqttConnected = false;
    connectMQTT();
  }

  // Phải chạy liên tục để nhận lệnh realtime!
  mqtt.loop();

  // Publish status every 1 second
  if (millis() - lastStatusUpdate >= STATUS_INTERVAL) {
    publishStatus();
    lastStatusUpdate = millis();
  }

  // Publish sensor data every 500ms
  if (millis() - lastSensorUpdate >= SENSOR_INTERVAL) {
    publishSensorData();
    lastSensorUpdate = millis();
  }

  // VERY SHORT DELAY - Quan trọng cho latency thấp!
  // Chỉ 5ms để mqtt.loop() kịp chạy
  delay(5);
}


